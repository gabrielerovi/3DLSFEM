def A(sigma,gdim,alpha,beta):
	return beta*sigma+alpha*tr(sigma)*Identity(gdim)
def epsilon(u):
    return sym(grad(u))	
def boundary(x, on_boundary):
    return on_boundary	
	
	
	
	# UFL input for mixed formulation of Poisson Equation
# ===================================================
# 
# First we define the variational problem in UFL which we save in the
# file called :download:`MixedPoisson.ufl`.
# 
# We begin by defining the finite element spaces. We define two finite
# element spaces :math:`\Sigma_h = BDM` and :math:`V_h = DG` separately,
# before combining these into a mixed finite element space: ::


gdim =2 
RT0 = VectorElement("RT", triangle, 1)
P1  = VectorElement("Lagrange", triangle, 1)
W = RT0 * P1

# The first argument to :py:class:`FiniteElement` specifies the type of
# finite element family, while the third argument specifies the
# polynomial degree. The UFL user manual contains a list of all
# available finite element families and more details.  The * operator
# creates a mixed (product) space ``W`` from the two separate spaces
# ``BDM`` and ``DG``. Hence,
# 
# .. math::
# 
#     W = \{ (\tau, v) \ \text{such that} \ \tau \in BDM, v \in DG \}.
# 
# Next, we need to specify the trial functions (the unknowns) and the
# test functions on this space. This can be done as follows ::

(sigma, u) = TrialFunctions(W)
(tau, v) = TestFunctions(W)

# Further, we need to specify the source :math:`f` (a coefficient) that
# will be used in the linear form of the variational problem. This
# coefficient needs be defined on a finite element space, but none of
# the above defined elements are quite appropriate. We therefore define
# a separate finite element space for this coefficient. ::

#CG = FiniteElement("CG", triangle, 1)
f = Coefficient(P1)


C_constitutive=Constant(triangle);
C_equilibrium=Constant(triangle);
beta=Constant(triangle)
alpha=Constant(triangle)

# Finally, we define the bilinear and linear forms according to the equations: ::

a = + C_equilibrium * inner(div(sigma),div(tau))*dx +C_constitutive * inner(A(sigma,gdim,alpha,beta)-epsilon(u),A(tau,gdim,alpha,beta)-epsilon(v))*dx 
L= C_equilibrium * inner(f,div(tau))*dx