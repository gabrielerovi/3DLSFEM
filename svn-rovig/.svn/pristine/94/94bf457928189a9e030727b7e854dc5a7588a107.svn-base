function [M_Normal_Tangent] = MatrixOnGammaCwithNormalTangentComponents(mesh)
% We want to express each variable on GammaC wrt its normal and tangent
% components, i.e; x= x_n + x_t
% EDGE variables:
% sigma n = s_n n + s_t t, i.e 
% c_1=(s_n n1  + s_t n2) / (phidotn)
% c_2=(s_n n2  - s_t n1) / (phidotn)
% NODE variables:
% u n = u_n n + u_t t, i.e 
% c_1=(u_n n1  + u_t n2)
% c_2=(u_n n2  - u_t n1)
% So basically we are writing, 


N=mesh.N;
NF=mesh.NF;
F_bc=mesh.F_bc;
face=mesh.face;
% we consider normal_node_contact instead of normal_node
% because it is better in case of angles
normal_node_contact=mesh.normal_node_contact;
normal_face=mesh.normal_face_contact;

[dirichlet,n_and_or_t,bool_bc]= boundary_value_bool(1);


[dirichlet_F,n_and_or_t,bool_bc]= boundary_value_bool(3);

M_Normal_Tangent=speye(3 * NF + 3 * N, 3 * NF + 3 * N);

for bb=mesh.F_contact
    

        for nn=1:3
        nodeN(nn)=face(bb,nn);
        normalN(:,nn)=normal_node_contact{face(bb,nn)};
        end
        normalF=normal_face{bb};
        
        phidotn=phi_dot_n(mesh,bb);
        
         normal_F=mesh.normal_face_contact{bb};
         [xn,H]=HouseHolderTransformation(sparse(3,3), normal_F);  
         M_Normal_Tangent( [bb, bb+NF, bb+2*NF] , :)=0;
         M_Normal_Tangent( [bb, bb+NF, bb+2*NF] , [bb, bb+NF, bb+2*NF] )= H*sign(phidotn);
        
        for nn=1:3
            for jj=1:3
                 nnode(jj) = 3 * NF + (jj-1)*N + nodeN(nn);
            end
            [xn,H]=HouseHolderTransformation(sparse(3,3), normalN(:,nn));
            M_Normal_Tangent( [nnode(1), nnode(2), nnode(3)] , : )=0;
            M_Normal_Tangent( [nnode(1), nnode(2), nnode(3)] , [nnode(1), nnode(2), nnode(3)] )=H;     
        end   
        
        
        
                   
end





end















